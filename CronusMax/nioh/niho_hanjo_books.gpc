/*
  Title: 인왕(PS4 버전) 무간옥 19층 한조 서점 (2층 시작점) 매크로
  Date: 2020-11-11
  Author: FreesiaBoy

  본 CronusMax GPC 스크립트는 "무간옥 한조를 잡고 떨어진 아이템을 수집하는 작업"을
  반복하는 매크로다. 아래 영상을 참고한다.
  Link:


  배경:
  인왕 커뮤니티에 알려져 있듯이 한조서점은 제조법서 노가다로 잘 알려져 있다.
  원하는 아이템을 제작하기 위해서는 먼저 제조법서를 먹어야 하는데 엄청 중요한 제조법서의 경우
  (예: 피이도, 피대식칼, 독깨기 시바타 투구, 등등) 일반 필드에서는 안나오고 무간옥에서만 준다. 
  본인은 별옵 열십자가 붙은 "피로 물든 두자루 칼"을 제조하고 싶어서 한조 서점 노가다에 대해 조사해 보았는데 
  해본 사람은 알겠지만 이걸 수동으로 하기에는 답이 없어 보였다.
  일단 무간옥 19층 피안에서 한조를 찾아야 한다. 그리고 한조를 쉽게 잡을 수 있도록 스펙이 되야 한다.
  무간옥 등반이 어느정도 되어 있어서 충분히 강화된 일도 발도셋(후쓰누시)이 있다면 발도로 한방에 보낼 수 있다. 
  또는 무간옥 20층 이상 등반을 안해도 인왕의 길 난이도에서 쉽게 맞출 수 있는 300+40 강화 무기로도 
  다이바와시나 미즈치 수호령을 이용해 자빠링+추가타를 이용해서 쉽게 잡을 수 있다. 
  어떻게 하든 한조를 한 번 잡는데 로딩 포함 대략 30초 내외가 걸린다. 무간옥 한조가 제조법서를 주는 확률이
  아이템 드랍율과 관계되어 있다고 말하는 사람도 있고 별로 느끼지 못하겠다는 사람도 있지만 풀세팅을 하든 안하든
  이런식으로 한시간을 잡으면 (산술적으로 한시간당 한조 120번을 잡는 것) 평균 4개에서 7개 사이의 제조법서를 
  먹는다고 알려져 있다. 따라서 자기가 원하는 제조법서를 먹기까지 재수없으면 하루 3시간씩 일주일 노가다를 해도
  못먹을 수 있다. 무엇보다 짧은 간격의 같은 동작을 반복하는게 육체적/정신적으로 힘들다.
  위와 같은 이유로 매크로를 만들게 되었다.


  매크로 사용 방법:
  우선 아래쪽 섹션에  작성된 대로 캐릭터 스펙 설정을 하고 술법 준비를 한다. (수라부, 금강부, 수호령소환부, 축지부)
  그 후 무간옥 한조 2층 시작맵을 찾아야 한다. 
  CronusMax에 본 매크로를 넣고, 한조 2층에서 축지부를 썼을때 시작하는 곳에서 L2를 누르면 매크로가 시작된다.
  매크로를 중지하려면 다시 L2를 누르면 된다.


  매크로 전체 단계:
  본 매크로는 크게 다섯 부분으로 구성되어 있다. 
  1. 수라부+극금부 버프
  2. 한조 위치까지 이동
  3. 한조 전투
  4. 루팅
  5. 축지부로 귀환


  캐릭터 스펙:
  무간옥 19층 한조를 찾기 전에 먼저 캐릭터 스펙 설정을 해야 한다. 본 매크로에서는 공중에서 한조를 내려찍은 후
  다이바와시+열십자 3방에 죽을 수 있도록 설정하였다. 이정도는 300+40 검호 이도를 포함, 
  야사카니 곡옥 포함 검호4 + 다테 4 세트만 맞추면 된다. 물론 검호 이도는 근공, 애용도, 공격력 반영이 
  달려 있어야 한다. 여기서 열십자를 사용하는게 매우 중요한데, 이유에 대해서는 아래 섹션에서 따로 언급한다.
  
  가장  중요한 것은 달리기 속도이다. 본 매크로는 무간옥 19층의 2층맵에서 한조를 잡기 전에 한조의 위치까지
  가는 단계가 있다. 이 때 각 지점의 정확한 위치까지 왼쪽 아날로그 방향키를 "정해진 시간" 동안 입력하도록 
  되어 있는데, 각 사용자마다 달리기 스펙이 다를 것이다. 달리기는 보통 방어구 다섯 부위 중 장갑을 제외한
  나머지에 담금질을 하는데 본 세팅의 경우 3부위에 애용도 0시 10.9% 달리기를 달아두었다. 물론 모든 장비는
  애용도가 다 차면 달리기가 15%에 근접한다. 달리기 스펙이 다르면 올바른 위치로 이동할 수 있도록 방향키 입력
  시간을 재조정 해줘야 한다. (이 부분은 CronusMax, PS4, 컴퓨터를 연결해서 코드를 수정하면서 수정된 코드를
  CronusMax에 넣고 PS4에서 다시 테스트하는 반복 과정을 거쳐야 할 것이다.)
  
  
  술법 준비:
  아이템 퀵슬롯은 한칸만 쓴다. 위쪽은 축지부, 좌측은 수호령 수환부, 우측은 금강부, 아래는 수라부
  
  
  열십자를 사용하는 이유:
  이도 열십자를 이용하는 것은 매우 중요하다. 록온을 한 후 한조를 가장 잘 추적하기 때문이다. 
  다이바와시 자빠링 후 열십자를 쓰지 않고 만약 추가타를 사용하려하면
  한조의 자빠링이 멀리 되는 경우에는 추가타를 못 먹이는 경우가 있다. 이러면 매크로는 입력된 반복동작을 할 뿐 
  한조의 행동을 알 수 없기 때문에 역으로 한조한테 죽을 수 있다. 한번 죽으면 수호령을 못 사용하고 결국 한조
  한테 또 죽게되고 그러면 무간옥에서 나와져 버리기 때문에 절대 이렇게 되면 안된다. 따라서 매크로는 가장 확실하면서
  보수적인 방법을 택해야 하는데 내가 알아낸 바로는 열십자가 가장 좋다.
  또 중요한 것은 항상 일정하게 다이바와시+열십자 3방에 죽여야 한다는 점이다. 
  인왕이 3D 게임이기 때문에 매크로로 항상 똑같은 동작을 해도 위치나 자리가 조금씩 미세하게 어긋난다.
  이것은 한조랑 싸울 때 뿐만 아니라 한조까지 걸어갈 때 약간 턱이 있는 언덕을 내려가도 발생하게 된다. 
  이런 이유로 매크로는 절대 달려가지 않고 기본 뛰기로 언덕을 돌아가게 해 둔 것이다.
  이러한 랜덤성은 한조를 처음 내려찍을 때 풀뎀이 들어가거나 반뎀이 들어가게 하는 경우도 있다.
  이 때문에 어떨때는 열십자 2방에 죽이고 어떨때는 열십자 3방에 죽이면 매크로는 항상 열십자 3방을
  입력하기 때문에 마지막 한조가 죽은 자리를 추적할 수 없다. 이렇게 되면 아이템이 떨어지는 자리에서 멀어지게 되고
  그러면 아이템 루팅을 올바르게 할 수 없게 된다.
  
  
  아이템 루팅 단계:
  마지막 열십자에 의해 한조가 죽더라도 아이템이 주위로 랜덤하게 튀면서 주위로 흩어진다. 
  매크로는 아이템이 어디에 떨어진지 모르기 때문에 그냥 한조를 죽인 마지막 자리에서 그 근처를 움직이면서
  동그라미 버튼을 다섯번 토글하도록 설정되어 있다. 따라서 어떤 경우에는 일부 아이템을 못 먹는 경우도 있다.
  그러나 현재 매크로 테스트 해 보면 대부분의 경우 다 먹거나 한 두개 빼고 다 먹게 된다. 어차피 사람이 하는게 
  아니라 매크로가 하는거니까 놓치더라도 아쉬워 하지 말자.
  
 
  알아둘 점:
  본 매크로에서 한조를 한 번 잡고 루팅하는데 까지 45초가 걸린다.
  인벤 크기가 500인데, 본인의 경우 장비와 템으로 120개가 채워져 있었다. 따라서 380칸의 여유가 있는데
  한조를 반복적으로 잡으면서 루팅을 하면 500개까지 채워지는데 대략 45분에서 50분이 걸린다. 
  따라서 50분에 한번씩 신사>봉납을 통해 먹은 아이템을 비워줘야 한다. 
  테스트 결과  제조법서는 인벤토리 칸을 차지하지 않았다. 따라서 인벤이 500개가 다 채워져서 한조를 계속 
  사냥하더라도 아이템은 못 먹더라도 "아마도" 제조법서는 먹지 않을까 하는데 테스트 해보지는 않았다.
  그냥 50분에 한번씩 비워주자. 물론 영계 아이템도 땅바닥에 다 버렸다.


  돌발 상황:
  본 매크로로 테스트 해 본 결과 20시간 이상 아무 문제 없이 계획대로 정상작동 되었다.
  그러나 혹시 한조까지 이동 구간에서 팔각정 문 옆에 언덕으로 못 내려가거나 또는 한조 첫번째 내려찍기를
  실패하는 사례가 있을 수 있다. 따라서 50분 또는 주기적으로 제조법서를 많이 모았다면 세이브 파일을 
  USB에 백업해 두자.
  
  
  매크로 수행 결과:
  개운부? 아이템 획득율?
  평균적 느낌 시간당 제조법서 3-4
  드믈게 7개
  연속 3시간 동안 한번도 안나온 경우도 있음
  산술적으로 ...

  TODO:
  1. 이동 동선 개선
  2. 장비 달리기 비율에 따른 이동 시간의 변수화 및 테스트
  3. 첫타에서 한조한테 맞지 않도록 다이바와시 소환 시간 개선
  4. 버튼 변수가 XBox 버튼으로 설정되어 있으나 단순히 int 일 뿐이기 때문에 PS4 버튼에 대응한다.
     코드를 더 깔끔하게 수정하고 싶으면 PS4 버튼 변수로 바꾸자.


  Build 정보:
	Compilation completed with 0 warning(s)
	Total byte size: 2369 bytes (57.84%)
	Total variables used: 7 of which 6 are dedicated to combos (6.25%)

*/ 


int switch = FALSE;

main {
    /* 실전 반복 용 */
    if (switch) {
        combo_run(maxcmb);
    } else  {   
        combo_stop(maxcmb);
    } 
    
    
    /* 한번만 돌아가는 테스트 용
    if (switch) {
        combo_run(maxcmb);
        switch = FALSE;
    } */
    
    if (event_press(XB1_LT)) {
        combo_run(cb_onoff);
    }
}

combo cb_onoff {
    wait(1000);
    switch = !switch;
}

combo maxcmb {

    // 수라부, 극금부
    set_val(XB1_DOWN, +100); 
    wait(100);
    wait(200);
    set_val(XB1_RIGHT, +100);
    wait(100);
    wait(200); 
    
    // 출발 -> 팔각정 중간지점
    set_val(XB1_LX, +0);
    set_val(XB1_LY, -100);
    wait(3800);
    wait(1000);
    // 팔각정 중간지점 -> 문 앞
    set_val(XB1_LX, -50);
    set_val(XB1_LY, -100);
    wait(1200);
    wait(1000);
    // 아래로 내려 감
    set_val(XB1_LX, +100);
    set_val(XB1_LY, +30);
    wait(1000);
    wait(1000); 
    // 앞으로 (언덕을 피해서) 진행
    // 언덕을 뛰어 내려가면 랜덤성이 강하다.
    set_val(XB1_LX, +20);
    set_val(XB1_LY, -100);
    wait(1000);
    wait(1000);
    set_val(XB1_LX, -90);
    set_val(XB1_LY, -67);
    wait(800);
    wait(1000);
   
    // 한조쪽으로 뛰어듬
    //set_val(XB1_LX, -100);
    //set_val(XB1_LY, -33);
    set_val(XB1_LX, -99);
    set_val(XB1_LY, -38);    
    //wait(850);
    wait(1200);
    wait(100);    
    
    
    // 내려 찍기
    set_val(XB1_X, +100);
    wait(100);
    wait(2000);
    // 한조 타겟
    set_val(XB1_RS, +100);
    wait(100);
    wait(200);
    // 다이바와시+열십자: 첫타
    set_val(XB1_LEFT, +100);
    wait(100);
    wait(1500);
    set_val(XB1_RB, +100);
    set_val(XB1_B, +100);
    wait(2000);
    wait(600);
    // 다이바와시+열십자: 이타
    set_val(XB1_LEFT, +100);
    wait(100);
    wait(1500);
    set_val(XB1_RB, +100);
    set_val(XB1_B, +100);
    wait(2000);
    wait(600); 
    // 다이바와시+열십자: 삼타
    set_val(XB1_LEFT, +100);
    wait(100);
    wait(1500);
    set_val(XB1_RB, +100);
    set_val(XB1_B, +100);
    wait(2000);
    wait(600); 

    // 제자리 루팅
    set_val(XB1_B, +100);
    wait(100);
    wait(100);
    set_val(XB1_B, +100);
    wait(100);
    wait(100);    
    set_val(XB1_B, +100);
    wait(100);
    wait(100);    
    set_val(XB1_B, +100);
    wait(100);
    wait(100);    
    set_val(XB1_B, +100);
    wait(100);
    wait(100);    

    // 앞쪽 이동 루팅
    set_val(XB1_LX, 0);
    set_val(XB1_LY, -100);
    wait(500);
    set_val(XB1_B, +100);
    wait(100);
    wait(100);
    set_val(XB1_B, +100);
    wait(100);
    wait(100);    
    set_val(XB1_B, +100);
    wait(100);
    wait(100);    
    set_val(XB1_B, +100);
    wait(100);
    wait(100);    
    set_val(XB1_B, +100);
    wait(100);
    wait(100);   

    // 좌측 이동 루팅
    set_val(XB1_LX, -100);
    set_val(XB1_LY, +0);
    wait(500);
    set_val(XB1_B, +100);
    wait(100);
    wait(100);
    set_val(XB1_B, +100);
    wait(100);
    wait(100);    
    set_val(XB1_B, +100);
    wait(100);
    wait(100);    
    set_val(XB1_B, +100);
    wait(100);
    wait(100);    
    set_val(XB1_B, +100);
    wait(100);
    wait(100);

    // 뒤쪽 이동 루팅
    set_val(XB1_LX, 0);
    set_val(XB1_LY, +100);
    wait(500);
    set_val(XB1_B, +100);
    wait(100);
    wait(100);
    set_val(XB1_B, +100);
    wait(100);
    wait(100);    
    set_val(XB1_B, +100);
    wait(100);
    wait(100);    
    set_val(XB1_B, +100);
    wait(100);
    wait(100);    
    set_val(XB1_B, +100);
    wait(100);
    wait(100); 

    // 우측 이동 루팅
    set_val(XB1_LX, +100);
    set_val(XB1_LY, +0);
    wait(500);
    set_val(XB1_B, +100);
    wait(100);
    wait(100);
    set_val(XB1_B, +100);
    wait(100);
    wait(100);    
    set_val(XB1_B, +100);
    wait(100);
    wait(100);    
    set_val(XB1_B, +100);
    wait(100);
    wait(100);    
    set_val(XB1_B, +100);
    wait(100);
    wait(100); 
    
    /* 축지부 사용 */
    set_val(XB1_UP, +100);
    wait(100);
    wait(500);
    set_val(XB1_B, +100);
    wait(100);
    wait(2000); 
    // 로딩
    wait(5000);
    

}







